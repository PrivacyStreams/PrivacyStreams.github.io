---
layout: homepage
title: Available pipeline (Transformation and Action) functions in PrivacyStreams
---

| Input -> Output | Tag | Reference & Description |
|----|----|----|
| `MStream->MStream` |  | `filter(Function<Item,Boolean> itemChecker)` <br> Filter the stream by testing an item with a function.  Specifically, keep the items that satisfy the function (aka. the function returns true).  Eg. `filter(eq("x", 100))` will keep the items whose x field is equal to 100.<br> - `itemChecker`:     the function to check each item. |
| `MStream->MStream` |  | `filter(String fieldName, TValue fieldValue)` <br> Filter the stream by checking whether a field equals a value.  Specifically, keep the items in which the field equals the given value.  Eg. `filter("x", 100)` will keep the items whose x field is equal to 100.<br> - `fieldName`:     the name of field to check<br> - `fieldValue`:    the value to compare with the field |
| `MStream->MStream` |  | `groupBy(String fieldName)` <br> Group the items according to a field.  After grouping, the item will only have two fields.  One is the field used for grouping by. Another is "grouped_items" which is a list of grouped Items.  Eg. `groupBy("x")` will group the items with same "x" field,  and the item in the stream after groupping will contain two fields: "x" and "grouped_items".<br> - `fieldName`:     the field used to group the items in current stream. |
| `MStream->MStream` |  | `limit(Function<Item,Boolean> itemChecker)` <br> Limit the stream by checking each item with a function.  Specifically, keep the stream as long as the checker holds (aka. the checker function returns true).  Eg. `limit(eq("x", 100))` will keep all items in the stream as long as x field equals to 100,  once an item's x value is not equal to 100, the stream stops.<br> - `itemChecker`:     the function to check each item. |
| `MStream->MStream` |  | `limit(int maxCount)` <br> Limit the stream with a max number of items.  Specifically, stop the stream if the count of items exceeds the threshold.  Eg. `limit(10)` will limit the stream to at most 10 items<br> - `maxCount`:      the max number of items |
| `MStream->MStream` |  | `localGroupBy(String fieldName)` <br> Group the **contiguous** items according to a field.  After grouping, the item will only have two fields.  One is the field used for grouping by. Another is "grouped_items" which is a list of grouped Items.  Eg.  `localGroupBy("x")` will group the contiguous items with same "x" field,  and the item in the stream after groupping will contain two fields: "x" and "grouped_items".<br> - `fieldName`:     the field used to reorder the stream |
| `MStream->MStream` |  | `logAs(String logTag)` <br> Print the items in current stream.<br> - `logTag`: the log tag to use in printing current stream |
| `MStream->MStream` |  | `map(Function<Item,Item> itemConverter)` <br> Convert each item in the stream with a function.  Eg. `map(ItemOperators.setField("x", 10))` will set the "x" field of each item to 10 in the stream.<br> - `itemConverter`:      the function to map each item to another item |
| `MStream->MStream` |  | `project(String fieldsToInclude)` <br> Project each item by including some fields.  Other fields will be removed.  Eg. `project("name", "email")` will only keep the "name" and "email" field in each item.<br> - `fieldsToInclude`: the fields to include |
| `MStream->MStream` |  | `reuse(int numOfReuses)` <br> Reuse current stream.<br> - `numOfReuses`: number of reuses |
| `MStream->MStream` |  | `reverse()` <br> Reverse the order of items  `reverse()` will reverse the order of the items in the stream. |
| `MStream->MStream` |  | `setField(String fieldToSet, Function<Item,TValue> fieldValueComputer)` <br> Set a field to a new value for each item in the stream.  The value is computed with a function that take the item as input.  Eg. `setField("x", Comparators.gt("y", 10))` will set a new boolean field "x" to each item,  which indicates whether the "y" field is greater than 10.<br> - `fieldToSet`: the name of the field to set.<br> - `fieldValueComputer`: the function to compute the value of the new field based on each item.<br> - `<TValue>`: the type of the new field value |
| `MStream->MStream` |  | `setGroupField(String fieldToSet, Function<List<Item>,TValue> fieldValueComputer)` <br> Set a field to a new value for each item in the stream.  This transformation can only be used after invoking group methods (`groupBy`, `localGroupBy`).  The value is computed with a function that takes the grouped items as input at runtime.  Eg. `setGroupField("count", StatisticOperators.count())` will set a new field "count" to each item,  which represents the number of items in the grouped sub stream.<br> - `fieldToSet`: the name of the field to set.<br> - `fieldValueComputer`: the function to compute the new field value, which takes the list of grouped items as input.<br> - `<TValue>`: the type of the new field value |
| `MStream->MStream` |  | `setIndependentField(String fieldToSet, Function<Void,TValue> valueGenerator)` <br> Set the value of a new field with a value generator function.  The value generator function is independent from current item, which does not need a input (input type is Void).  The value generator will be evaluated on demand at runtime.  Eg. `setIndependentField("time", TimeOperators.getCurrentTime())` will set the field "time" to a timestamp in each item;  `setIndependentField("wifiStatus", DeviceOperators.isWifiConnected())` will set the field "wifiStatus" to a boolean indicating whether wifi is connected in each item.<br> - `fieldToSet`: the name of the field to set.<br> - `valueGenerator`: the function to compute the field value.<br> - `<TValue>`: the type of the new field value. |
| `MStream->MStream` |  | `shuffle()` <br> Shuffle the items.  `shuffle()` will randomize the order of the items in the stream. |
| `MStream->MStream` |  | `sortBy(String fieldName)` <br> Sort the items according to the value of a field, in ascending order.  Eg. `sortBy("timestamp")` will sort the items in the stream by timestamp field.<br> - `fieldName`:     the field used to sort the items in current stream, in ascending order |
| `MStream->MStream` |  | `timeout(long timeoutMilliseconds)` <br> Limit the stream with a timeout, stop the stream after time out.  Eg. `timeout(Duration.seconds(10))` will limit the stream to at most 10 seconds<br> - `timeoutMilliseconds`:      the timeout milliseconds |
| `MStream->SStream` |  | `getFirst()` <br> Get the first item in the stream. |
| `MStream->SStream` |  | `getItemAt(int index)` <br> Pick an item in the stream.<br> - `index`: the index of target item. |
| `MStream->SStream` |  | `select(Function<List<Item>,Item> selector)` <br> Select an item in the stream with a function.<br> - `selector`: the selector funtion to select the target item. |
| `SStream->SStream` |  | `logAs(String logTag)` <br> Print the items in current stream.<br> - `logTag`: the log tag to use in printing current stream |
| `SStream->SStream` |  | `map(Function<Item,Item> function)` <br> Convert the item in the stream with a function.  Eg. `map(ImageOperators.blur("image"))` will blur the image specified by "image" field in the item.<br> - `function`:      the function to convert the item |
| `SStream->SStream` |  | `project(String fieldsToInclude)` <br> Project the item by including some fields.  Other fields will not appear in collectors, such as toMap().  eg. `project("name", "email")` will only keep the "name" and "email" field in the item<br> - `fieldsToInclude`: the fields to include |
| `SStream->SStream` |  | `reuse(int numOfReuses)` <br> Reuse current stream.<br> - `numOfReuses`: number of reuses |
| `SStream->SStream` |  | `setField(String newField, Function<Item,TValue> functionToComputeField)` <br> Set a field with a function that takes the item as input.<br> - `newField`: the new field name<br> - `functionToComputeField`: the function to compute the new field value<br> - `<TValue>`: the type of the new field value |
| `SStream->SStream` |  | `setIndependentField(String fieldToSet, Function<Void,TValue> valueGenerator)` <br> Set the value of a new field with a value generator function.  The value generator function is independent from current item, which does not need a input (input type is Void).  The value generator will be evaluated on demand at runtime.  Eg. `setIndependentField("time", TimeOperators.getCurrentTime())` will set the field "time" to a timestamp in each item;  `setIndependentField("wifiStatus", DeviceOperators.isWifiConnected())` will set the field "wifiStatus" to a boolean indicating whether wifi is connected in each item.<br> - `fieldToSet`: the name of the field to set, it can be a new name or an existing name.<br> - `valueGenerator`: the function to compute the field value.<br> - `<TValue>`: the type of the new field value. |

Actions:

| Input -> Output | Tag | Reference & Description |
|----|----|----|
| `MStream->List<Item>` | Blocking | `asList()` <br> Collect the items in the stream to a list.  Each item in the list is an instance of `Item`. |
| `MStream->List<TValue>` | Blocking | `asList(String fieldToSelect)` <br> Select a field in each item and output the items to a list.<br> - `fieldToSelect`: the field to select<br> - `<TValue>`: the type of field value |
| `MStream->Tout` | Blocking | `output(Function<List<Item>,Tout> itemsCollector)` <br> Output the items in the stream with a function.  This method will block until the result returns.  Eg. `output(StatisticOperators.count())` will output the number of items.<br> - `itemsCollector`: the function used to output current stream<br> - `<Tout>`: the type of the result |
| `MStream->int` | Blocking | `count()` <br> Count the number of items. |
| `MStream->void` | Non-blocking | `debug()` <br> Print the items for debugging. |
| `MStream->void` | Non-blocking | `forEach(Function<Item,Void> callback)` <br> Callback with each item.<br> - `callback`: the callback to invoke for each item. |
| `MStream->void` | Non-blocking | `forEach(String fieldToSelect, Callback<TValue> callback)` <br> Callback with a certain field of each item.<br> - `fieldToSelect`: the name of the field to callback with<br> - `callback`: the callback to invoke for each item field<br> - `<TValue>`: the type of the field |
| `MStream->void` | Non-blocking | `ifPresent(Function<Item,Void> callback)` <br> Callback with an item once one item is present.<br> - `callback`: the callback to invoke once the item is present |
| `MStream->void` | Non-blocking | `ifPresent(String fieldToSelect, Callback<TValue> callback)` <br> Callback with a field value of an item once the field value is present.<br> - `fieldToSelect`: the name of the field to callback with<br> - `callback`: the callback to invoke once the field value is present<br> - `<TValue>`: the type of the field |
| `MStream->void` | Non-blocking | `onChange(Function<Item,Void> callback)` <br> Callback with an item when the item changes (is different from the previous item).<br> - `callback`: the callback to invoke for the changed item |
| `MStream->void` | Non-blocking | `onChange(String fieldToSelect, Callback<TValue> callback)` <br> Callback with a field value of an item when the field value changes.<br> - `fieldToSelect`: the name of the field to callback with<br> - `callback`: the callback to invoke for the changed item field<br> - `<TValue>`: the type of the field |
| `MStream->void` | Non-blocking | `output(Function<List<Item>,Tout> resultComputer, Callback<Tout> resultHandler)` <br> Output the items in the stream with a function, and pass the result to a callback.  This method will not be blocked.  Eg. `outputItems(StatisticOperators.count(), new Callback<Integer>(){...})`  will count the number of items and callback with the number.<br> - `resultComputer`: the function used to compute result based on the items in current stream<br> - `resultHandler`: the function to handle the result<br> - `<Tout>`: the type of the result |
| `SStream->Item` | Blocking | `asItem()` <br> Output the item by returning the key-value map.  The keys in the map can be selected using project(String... fieldsToInclude) method. |
| `SStream->TValue` | Blocking | `getField(String field)` <br> Get the value of a field.<br> - `field`: the name of the field to get<br> - `<TValue>`: the type of the new field value |
| `SStream->void` | Non-blocking | `debug()` <br> Print this stream for debugging. |
| `SStream->void` | Non-blocking | `ifPresent(Function<Item,Void> callback)` <br> Once an item is present, callback with the item.<br> - `callback`: the callback to invoke with the item. |
| `SStream->void` | Non-blocking | `ifPresent(String fieldToSelect, Callback<TValue> callback)` <br> Once an item is present and the field is valid, Callback with the field value.<br> - `fieldToSelect`: the name of the field.<br> - `callback`: the callback to invoke with the field valu.<br> - `<TValue>`: the type of the field. |
| `SStream->void` | Non-blocking | `output(Function<Item,Tout> itemCollector, Callback<Tout> resultHandler)` <br> Output the item in the stream with a function, and the result is delivered to a callback function.  This method will NOT block.<br> - `itemCollector`: the function used to output the current item<br> - `resultHandler`: the function to handle the result<br> - `<Tout>`:           the type of result |
