---
layout: homepage
title: Available pipeline (Transformation and Action) functions in PrivacyStreams
---

## Transformations

| Input -> Output | Tag | Reference & Description |
|----|----|----|
| `PStream->PStream` |  | `filter(Function<Item,Boolean> itemChecker)` <br> Filter the stream by testing an item with a function.  Specifically, keep the items that satisfy the function (aka. the function returns true).  Eg. `filter(eq("x", 100))` will keep the items whose x field is equal to 100.<br> - `itemChecker`: the function to check each item. |
| `PStream->PStream` |  | `filter(String fieldName, TValue fieldValue)` <br> Filter the stream by checking whether a field equals a value.  Specifically, keep the items in which the field equals the given value.  Eg. `filter("x", 100)` will keep the items whose x field is equal to 100.<br> - `fieldName`: the name of field to check<br> - `fieldValue`: the value to compare with the field |
| `PStream->PStream` |  | `groupBy(String groupField)` <br> Group the items according to a field.  After grouping, the items in the new stream will only have two fields.  One is the field used for grouping by. Another is "grouped_items" which is a list of grouped Items.  Eg. `groupBy("x")` will group the items with same "x" field,  and the item in the stream after groupping will contain two fields: "x" and "grouped_items".<br> - `groupField`: the field used to group the items in current stream. |
| `PStream->PStream` |  | `inFixedInterval(long fixedInterval)` <br> Make the items be sent in a fixed interval.  Eg. If a stream has items sent at 1ms, 3ms, 7ms, 11ms and 40ms,  `inFixedInterval(10)` will send items at 7ms, 11ms, 11ms and 40ms, in a 10ms interval.<br> - `fixedInterval`: the fixed interval in milliseconds. |
| `PStream->PStream` |  | `keepChanges()` <br> Only keep the items that are different from the previous ones in the stream.  Eg. a stream [1, 1, 2, 2, 2, 1, 1] will be [1, 2, 1] after `keepChanges()` |
| `PStream->PStream` |  | `keepChanges(String fieldName)` <br> Only Keep the items whose fields are different from the previous ones in the stream.  Similar to `keepChanges()`, but only monitor a certain field<br> - `fieldName`: the name of field to check whether an item should be kept |
| `PStream->PStream` |  | `limit(Function<Item,Boolean> itemChecker)` <br> Limit the stream by checking each item with a function.  Specifically, keep the stream as long as the checker holds (aka. the checker function returns true).  Eg. `limit(eq("x", 100))` will keep all items in the stream as long as x field equals to 100,  once an item's x value is not equal to 100, the stream stops.<br> - `itemChecker`: the function to check each item. |
| `PStream->PStream` |  | `limit(int maxCount)` <br> Limit the stream with a max number of items.  Specifically, stop the stream if the count of items exceeds the threshold.  Eg. `limit(10)` will limit the stream to at most 10 items<br> - `maxCount`:      the max number of items |
| `PStream->PStream` |  | `localGroupBy(String groupField)` <br> Group the **contiguous** items according to a field.  After grouping, the items in the new stream will only have two fields.  One is the field used for grouping by. Another is "grouped_items" which is a list of grouped Items.  Eg.  `localGroupBy("x")` will group the contiguous items with same "x" field,  and the item in the stream after groupping will contain two fields: "x" and "grouped_items".<br> - `groupField`: the field used to group the items in current stream. |
| `PStream->PStream` |  | `logAs(String logTag)` <br> Print the items in current stream.<br> - `logTag`: the log tag to use in printing current stream |
| `PStream->PStream` |  | `logOverSocket(String logTag)` <br> Print the items in current stream over socket.<br> - `logTag`: the log tag to use in printing current stream |
| `PStream->PStream` |  | `map(Function<Item,Item> itemConverter)` <br> Convert each item in the stream with a function.  Eg. `map(ItemOperators.setField("x", 10))` will set the "x" field of each item to 10 in the stream.<br> - `itemConverter`:      the function to map each item to another item |
| `PStream->PStream` |  | `project(String fieldsToInclude)` <br> Project each item by including some fields.  Other fields will be removed.  Eg. `project("name", "email")` will only keep the "name" and "email" field in each item.<br> - `fieldsToInclude`: the fields to include |
| `PStream->PStream` |  | `reuse(int numOfReuses)` <br> Reuse current stream.<br> - `numOfReuses`: number of reuses |
| `PStream->PStream` |  | `reverse()` <br> Reverse the order of items  `reverse()` will reverse the order of the items in the stream. |
| `PStream->PStream` |  | `sampleByCount(int stepCount)` <br> Sample the items based on a given step count. The items are filtered to make sure  `stepCount` number of items are dropped between each two new items.  Eg. `sampleByCount(2)` will keep the 1st, 4th, 7th, 10th, ... items<br> - `stepCount`: the num of items to drop since last item |
| `PStream->PStream` |  | `sampleByInterval(long minInterval)` <br> Sample the items based on a given interval. The items sent within the time interval  since last item are dropped.  Eg. If a stream has items sent at 1ms, 3ms, 7ms, 11ms and 40ms,  `sampleByInterval(10)` will only keep the items sent at 1ms, 11ms and 40ms.<br> - `minInterval`: the minimum interval (in milliseconds) between each two items. |
| `PStream->PStream` |  | `setField(String fieldToSet, Function<Item,TValue> fieldValueComputer)` <br> Set a field to a new value for each item in the stream.  The value is computed with a function that take the item as input.  Eg. `setField("x", Comparators.gt("y", 10))` will set a new boolean field "x" to each item,  which indicates whether the "y" field is greater than 10.<br> - `fieldToSet`: the name of the field to set.<br> - `fieldValueComputer`: the function to compute the value of the new field based on each item.<br> - `<TValue>`: the type of the new field value |
| `PStream->PStream` |  | `setGroupField(String fieldToSet, Function<List<Item>,TValue> fieldValueComputer)` <br> Set a field to a new value for each item in the stream.  This transformation can only be used after invoking group methods (`groupBy`, `localGroupBy`).  The value is computed with a function that takes the grouped items as input at runtime.  Eg. `setGroupField("count", StatisticOperators.count())` will set a new field "count" to each item,  which represents the number of items in the grouped sub stream.<br> - `fieldToSet`: the name of the field to set.<br> - `fieldValueComputer`: the function to compute the new field value, which takes the list of grouped items as input.<br> - `<TValue>`: the type of the new field value |
| `PStream->PStream` |  | `setIndependentField(String fieldToSet, Function<Void,TValue> valueGenerator)` <br> Set the value of a new field with a value generator function.  The value generator function is independent from current item, which does not need a input (input type is Void).  The value generator will be evaluated on demand at runtime.  Eg. `setIndependentField("time", TimeOperators.getCurrentTime())` will set the field "time" to a timestamp in each item;  `setIndependentField("wifiStatus", DeviceOperators.isWifiConnected())` will set the field "wifiStatus" to a boolean indicating whether wifi is connected in each item.<br> - `fieldToSet`: the name of the field to set.<br> - `valueGenerator`: the function to compute the field value.<br> - `<TValue>`: the type of the new field value. |
| `PStream->PStream` |  | `shuffle()` <br> Shuffle the items.  `shuffle()` will randomize the order of the items in the stream. |
| `PStream->PStream` |  | `sortBy(String fieldName)` <br> Sort the items according to the value of a field, in ascending order.  Eg. `sortBy("timestamp")` will sort the items in the stream by timestamp field.<br> - `fieldName`:     the field used to sort the items in current stream, in ascending order |
| `PStream->PStream` |  | `timeout(long timeoutMilliseconds)` <br> Limit the stream with a timeout, stop the stream after time out.  Eg. `timeout(Duration.seconds(10))` will limit the stream to at most 10 seconds<br> - `timeoutMilliseconds`:      the timeout milliseconds |
| `PStream->PStream` |  | `unGroup(String unGroupField, String newField)` <br> Un-group a list field in each item to multiple items.  Each element in the list will be a new field in each item of the new stream.  After un-grouping, the items in the new streams will have the same amount of fields  as the original stream.  However, the list field (`unGroupField`) will be replaced by a new field (`newField`).  Eg.  `unGroup("emails", "email")` will un-group the "emails" field (which is a list)  in an item to several new items with a "email" field.<br> - `unGroupField`: the field to un-group, whose value should be a list<br> - `newField`: the new field name in the new stream |

## Actions

| Input -> Output | Tag | Reference & Description |
|----|----|----|
| `PStream->Item` | Blocking | `getFirst()` <br> Get the first item in the stream. |
| `PStream->Item` | Blocking | `getItemAt(int index)` <br> Pick the N-th item in the stream. N is the index.<br> - `index`: the index of target item. |
| `PStream->List<Item>` | Blocking | `asList()` <br> Collect the items in the stream to a list.  Each item in the list is an instance of `Item`. |
| `PStream->List<TValue>` | Blocking | `asList(String fieldToSelect)` <br> Select a field in each item and output the field values to a list.<br> - `fieldToSelect`: the field to select<br> - `<TValue>`: the type of field value |
| `PStream->TValue` | Blocking | `getFieldAt(String fieldName, int index)` <br> Get the N-th value of a given field. N is the index.<br> - `fieldName`: the name of the field to select<br> - `index`: the index of target item. |
| `PStream->TValue` | Blocking | `getFirst(String fieldName)` <br> Get the first value of the given field in the stream. |
| `PStream->Tout` | Blocking | `output(Function<List<Item>,Tout> itemsCollector)` <br> Output the items in the stream with a function.  This method will block until the result returns.  Eg. `output(StatisticOperators.count())` will output the number of items.<br> - `itemsCollector`: the function used to output current stream<br> - `<Tout>`: the type of the result |
| `PStream->int` | Blocking | `count()` <br> Count the number of items. |
| `PStream->void` | Non-blocking | `debug()` <br> Print the items for debugging. |
| `PStream->void` | Non-blocking | `forEach(Function<Item,Void> callback)` <br> Callback with each item.<br> - `callback`: the callback to invoke for each item. |
| `PStream->void` | Non-blocking | `forEach(String fieldToSelect, Function<TValue,Void> callback)` <br> Callback with a certain field of each item.<br> - `fieldToSelect`: the name of the field to callback with<br> - `callback`: the callback to invoke for each item field<br> - `<TValue>`: the type of the field |
| `PStream->void` | Non-blocking | `idle()` <br> Do nothing with the items. |
| `PStream->void` | Non-blocking | `ifPresent(Function<Item,Void> callback)` <br> Callback with an item once one item is present.<br> - `callback`: the callback to invoke once the item is present |
| `PStream->void` | Non-blocking | `ifPresent(String fieldToSelect, Function<TValue,Void> callback)` <br> Callback with a field value of an item once the field value is present.<br> - `fieldToSelect`: the name of the field to callback with<br> - `callback`: the callback to invoke once the field value is present<br> - `<TValue>`: the type of the field |
| `PStream->void` | Non-blocking | `onChange(Function<Item,Void> callback)` <br> Callback with an item when the item changes (is different from the previous item).<br> - `callback`: the callback to invoke for the changed item |
| `PStream->void` | Non-blocking | `onChange(String fieldToSelect, Function<TValue,Void> callback)` <br> Callback with a field value of an item when the field value changes.<br> - `fieldToSelect`: the name of the field to callback with<br> - `callback`: the callback to invoke for the changed item field<br> - `<TValue>`: the type of the field |
| `PStream->void` | Non-blocking | `output(Function<List<Item>,Tout> resultComputer, Callback<Tout> resultHandler)` <br> Output the items in the stream with a function, and pass the result to a callback.  This method will not be blocked.  Eg. `outputItems(StatisticOperators.count(), new Callback<Integer>(){...})`  will count the number of items and callback with the number.<br> - `resultComputer`: the function used to compute result based on the items in current stream<br> - `resultHandler`: the function to handle the result<br> - `<Tout>`: the type of the result |
